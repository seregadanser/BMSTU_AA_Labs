\chapter{Аналитическая часть}

\section{Описание алгоритмов}
В этом разделе будут рассмотрены следующие алгоритмы сортировки: плавная, слиянием, блочная.

\subsection{Плавная сотрировка}
Разработана известным ученым Э. Дейкстрой в 1981 году \cite{ss}.
Является подвидом пирамидальной сортировки. Различие состоит в том, что в сортировке кучей используются бинарное дерево. А в плавной сортировке элеименты дерева сотоят из деревьев размером с одно из чисел Леонардо. 

Числа Леонардо представляют собой последовательность, вычисляемую по формуле:
\[L(0) = 1;\]
\[L(1) = 1;\]
\[L(n) = L(n-1) + L (n-2) + 1;\]

Общие положения следующие.
\begin{enumerate}
\item Сортируемый массив делится на группу подмассивов. Каждый подмассив представляет собой структуру данных куча. Каждая куча имеет размер равный одному из чисел Леонардо. При этом левые элементы массива являются узлами самой большой возможной кучи. Оставшиеся элементы массива разбиваются на кучи по такому же жадному правилу. В дальнейшем эту группу подмассивов будем называть последовательность куч. При этом, элементы этой последовательности будут строго уменьшаться в размере с ростом порядкового номера.
\item Не существует двух куч, имеющих одинаковый размер.
\item Никакие две кучи не будут иметь размер равным двум последовательным числам Леонардо. Исключением могут быть только две последние кучи.
Если мы будем использовать подряд две кучи размерностью $L(x)$ и $L(x+1)$, то их можно будет заменить одной – размерностью $L(x+2)$
\end{enumerate}

Следствия.
\begin{enumerate}
\item В вершине каждой кучи находится максимальный из узлов данной кучи.
\item Максимальный элемент массива нужно искать среди вершин сформированных куч.
\end{enumerate}

Алгоритм состоит из двух этапов.
\begin{itemize}
\item Формирование последовательности куч:
в начале последовательность куч пуста, последовательно добавляются элементы из исходного массива слева направо. Элемент, который будет добавляться в последовательность куч выступает либо в качестве вершины абсолютно новой кучи, либо в качестве вершины, которая объединит две последние кучи. Повторяем эту итерацию пока не закончатся элементы во входном массиве.
\item Формирование отсортированного массива:
на каждой итерации определяем текущий максимум массива, используя следствие 2. Ставим максимальный элемент на последнее место и исключаем его из последовательности куч. Повторяем это действие, пока последовательность куч не окажется пуста.
\end{itemize}

Замечание:
при объединении двух куч в одну и и при обмене двух вершинных элементов нужно гарантировать сохранение свойства кучи, т.е. выполнять “просейку вниз” при необходимости.
\subsection{Сортировка слиянием}
Данная сортировка была разработана Джоном фон Нейманом в 1945 году и относиться к классу рекурсивных алгоритмов \cite{algos}. 
Алгоритм работает следующим образом.
\begin{itemize}
\item Массив рекурсивно разбивается пополам, и каждая из половин делится до тех пор, пока размер очередного подмассива не станет равным единице.

\item Далее выполняется операция алгоритма, называемая слиянием. Два единичных массива сливаются в общий результирующий массив, при этом из каждого выбирается меньший элемент (сортировка по возрастанию) и записывается в свободную левую ячейку результирующего массива. После чего из двух результирующих массивов собирается третий общий отсортированный массив, и так далее. В случае, если один из массивов закончится, элементы другого дописываются в собираемый массив.

\item В конце операции слияния, элементы перезаписываются из результирующего массива в исходный.
\end{itemize}

\subsection {Блочная сортировка}
Алгоритм сортировки, который работает путем распределения элементов массива по нескольким сегментам. Затем каждая корзина сортируется индивидуально, либо с использованием другого алгоритма сортировки, либо путем рекурсивного применения блочной сортировки \cite{algos}.

Алгоритм работает следующим образом.
\begin{itemize}
\item Пусть $l$ – минимальный, а $r$ – максимальный элемент массива. Разобьем элементы на блоки, в первом будут элементы от $l$ до $l + k$, во втором – от $l + k$ до $l + 2k$ и т.д., где $k = (r – l) / \textup{количество блоков}$.
\item Сортируем все получившиеся блоки другим алгоритмом сортировки.
\item Выполним слияние блоков в единый массив.
\end{itemize}