\chapter{Аналитическая часть}
\section{Матрица}
Пусть есть два конечных множества.
\begin{itemize}
	\item  Номера строк: $M = {1, 2, ..., m}$.
	\item  Номера столбцов: $N = {1, 2, ..., n}$. 
\end{itemize}
Где $m$ и $n$ --- натуральные числа.
Тогда матрицей $A$  размера $m$ на $n$ называется структура вида:  
\begin{equation}
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{m2} & \ldots & a_{mn}
	\end{pmatrix};
\end{equation}
где элемент матрицы $a_{ij}$  находится на пересечении i-й строки и j-го столбца. При этом количество элементов матрицы равно $m * n$.

Можно выделить следующие операции над матрицами:
\begin{enumerate}
	\item[1)]  сложение матриц одинакового размера;
	\item[2)]  вычитание матриц одинакового размера;
	\item[3)]  умножение матриц в случае, если количество столбцов первой матрицы равно количеству строк второй матрицы. В итоговой матрице количество строк будет, как у первой матрицы, а столбцов -- как у второй. \newline
\end{enumerate}

\textit{Замечание:} операция умножения матриц не коммутативна -- если \textit{A} и \textit{B} -- квадратные матрицы, а \textit{C} -- результат их перемножения, то произведение \textit{AB} и \textit{BA} дадут разный результат \textit{C}.


\section{Описание алгоритмов}
В этом разделе будут рассмотрены следующие алгоритмы матричного умножения: классический, Винограда, оптимизированный Винограда.

\subsection{Классический алгоритм умножения матриц}

Пусть даны две матрицы

\begin{equation}
	A_{lm} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{l1} & a_{l2} & \ldots & a_{lm}
	\end{pmatrix},
	\quad
	B_{mn} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mn}
	\end{pmatrix},
\end{equation}

тогда матрица $C$
\begin{equation}
	C_{ln} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{l1} & c_{l2} & \ldots & c_{ln}
	\end{pmatrix},
\end{equation}

где
\begin{equation}
	\label{eq:M}
	c_{ij} =
	\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
\end{equation}

будет называться произведением матриц $A$ и $B$.

Стандартный алгоритм  реализует данную формулу.


\subsection{Алгоритм Винограда}

\textbf{Алгоритм Винограда}  -- алгоритм умножения квадратных матриц. Начальная версия имела асимптотическую сложность алгоритма примерно $O(n^{2,3755})$, где $n$ -- размер стороны матрицы, но после доработки он стал обладать лучшей асимптотикой среди всех алгоритмов умножения матриц.

Рассмотрим два вектора $U = (u_1, u_2, u_3, u_4)$ и $W = (w_1, w_2, w_3, w_4)$.
Их скалярное произведение равно: $U \cdot W = u_1w_1 + u_2w_2 + u_3w_3 + u_4w_4$, что эквивалентно (\ref{for:new}):
\newpage
\begin{equation}
	\label{for:new}
	V \cdot W = (u_1 + w_2)(u_2 + w_1) + (u_3 + w_4)(u_4 + w_3) - u_1u_2 - u_3u_4 - w_1w_2 - w_3w_4.
\end{equation}

За счёт предварительной обработки данных можно получить прирост производительности: несмотря на то, что  полученное выражение требует большего количества операций, чем стандартное умножение матриц, выражение в правой части равенства можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы. 
Это позволит выполнить лишь два умножения и пять сложений, при учёте, что потом будет сложено только с двумя предварительно посчитанными суммами соседних элементов текущих строк и столбцов. 
Операция сложения выполняется быстрее, поэтому на практике алгоритм должен работать быстрее обычного алгоритма перемножения матриц.

Стоит упомянуть, что при нечётном значении размера матрицы нужно дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.

\subsection{Оптимизация алгоритма Винограда}

При программной реализации рассмотренного выше алгоритма Винограда можно провести оптимизации.
\begin{enumerate}
	\item Операции сложения и вычитания с присваиванием следует реализовывать при помощи соответствующего оператора $+=$ или $-=$ (при наличии данных операторов в выбранном языке программирования).
	\item Операцию умножения на 2 программно эффективнее реализовывать как побитовый сдвиг влево на 1.
	\item Занесение в циклах вычисления множителей вычисления первых двух
	элементов во внутренний цикл j.
\end{enumerate}